module Physics
using SFML
using Math: transform, jacobian
""""
The mechanical state contains the state of our system.
"""
type MechanicalState
    pos::Vector{Float64}
    velocity::Vector{Float64}
    inertia::Matrix{Float64}
    forces::Vector
    constraint
    constraintJacobian::Matrix{Float64}
    Jprev::Matrix{Float64}
end

function MechanicalState()
  MechanicalState([], [], eye(0), [], x -> x, eye(0), eye(0)) 
end

"""
This function is responsible to compute the acceleration due to constraints. I.e it computes lagrange multipliers
"""
function multipliersAcceleration(state::MechanicalState, dt::Float64)
    a = gravityAcceleration(state, dt) + forceAcceleration(state, dt)
    M = state.inertia
    x = state.pos
    v = state.velocity
    state.constraintJacobian = jacobian(state.constraint, x)
    J = state.constraintJacobian
    Jprev = state.Jprev
    
    J_dt = (J - Jprev) / dt
    Jv = J_dt * v
    Minv = inv(M)
    l = -(J * Minv * J') \ (Jv + (J * a))

    state.Jprev = J
    Minv * J' * l
end

"""
This fonction computes the acceleration generated by the forces applied on our system. 
"""
function forceAcceleration(state::MechanicalState, dt::Float64)
    M = state.inertia
    x = state.pos
    v = state.velocity
    forces = state.forces
    
    f = fill(0, length(state.pos))

    for i=1:length(state.forces)
        f += forces[i](x,v)
    end
    
    M \ f
end

"""
This function integrates acceleration and velocity to get the new state of our system.
"""
function integrate(state::MechanicalState, dt::Float64, force::Vector2f)
    a = gravityAcceleration(state, dt) + forceAcceleration(state, dt) + multipliersAcceleration(state, dt)
    state.velocity = state.velocity +  a * dt
    state.pos = state.pos + state.velocity * dt
end

"""
Initialize some data of our system.
"""
function init(state::MechanicalState)
    state.Jprev = jacobian(state.constraint, state.pos)
end

"""
This adds a new body to our system. Each body is supposed to have two degrees of freedom. 
"""
function addBody(state::MechanicalState, pos::Vector{Float64}, vel::Vector{Float64}, mass::Matrix{Float64})
    append!(state.pos, pos)
    append!(state.velocity, vel)

    nr, nc = size(state.inertia)
    new = eye(length(state.pos))
    new[1:nr, 1:nc] = state.inertia
    new[nr+1:end, nc+1:end] = mass
    state.inertia = new
end

"""
This adds a forces to our system. A force is a function that take position and velocity and returns a forces.

#Exampe:
```julia
function s(x::Vector{Float64}, v::Vector{Float64})
  f = fill(0.0, length(x))
  f[coordIdx] = - stiffness * ((x[coordIdx] - restLength) - restPos) - damping * v[coordIdx]
  f
end
```
"""
function addForce(state::MechanicalState, f)
    push!(state.forces, f)
end


"""
Create a vector containing accelerations due to gravity.
"""
function gravityAcceleration(state::MechanicalState, dt::Float64)::Vector{Float64}
    a = []
    for i=1:length(state.pos)/3
        a = append!(a,[0, -9.81, 0.])
    end
    a
end

end
